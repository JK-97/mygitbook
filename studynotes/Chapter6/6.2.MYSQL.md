# 6.2.MYSQL

### 6.2.1.MYSQL概念

**常考察点**

- 事务原理，特性，事务的并发控制
- 常用字段，含义，区别
- 常用数据库引擎的区别

**事务 Transaction**

- 事务是数据库并发控制的基本单位
- 事务可以看作是一系列SQL语句的集合
- 事务必须要么全部执行成功，要么全部执行失败

**特性ACID**

- 原子性(Atomicity)：一个事务所有操作全部完成或失败
- 一致性(Consistency):事务开始和结束后数据的完整性没有被破坏
- 隔离性(Isolation):允许多个事务同时对数据库修改和读写
- 持久性(Durability)：事务结束后，修改时永久不会丢失的

**事务的并发可能会产生的四种异常情况**

- 幻读(phanton read):一个事务第二次查出第一次没有的结果
- 非重复读(nonrepeatable read): 一个事务重复读两次得到不同结果
- 脏读(dirty read):一个事务读取到另外一个事务没有提交的修改
- 丢失修改(lost update):并发写入造成其中一些修改丢失

**四种事务隔离级别**

- 读取提交(read uncommitted):别的事务可以读取到未提交改变
- 读已提交(read committed):只能读取已提交的数据
- 可重复读(repeatable read):同一个事务先后查询结果一样(Mysql InoDB默认实现可重复读级别)
- 串行化(Serialzavle)：事务串行化的执行，隔离级别最高，执行效率最低

**如何解决并发场景下的插入重复**

- 使用数据库的唯一索引(一般情况用不了，一般项目会建库建表)
- 使用队列异步写入
- 使用redis等实现分布式锁

**乐观锁和悲观锁**

- 悲观锁是先获取在进行操作。一锁二查三更新select for update
- 乐观锁先修改，更新的时候发现数据已经变了就回滚(测check and set)
- 根据响应速度，冲突频率，重试代价来判断选择哪种

**MYSQL数据类型**

1. 字符串
   CHAR:存储定长字符串
   VARCHAR：存储不定长字符串
   TEXT:存储较长的文章
2. 数值
   TINTINT,INT,BIGINT,DOUBLE等
3. 日期和时间
   DATE：YYYY-MM-DD
   DATETIME:YYYY-MM-DD HH:MM:SS

**Mysql常用引擎**

- MyISAM不支持事务，InnoDB支持事务
- MyISAM不支持外键，InnoDB支持外键
- MyISAM只支持表锁，InnoDB支持表锁和行锁

### 6.2.2.索引原理以及优化

- 索引的原理，类型，结构
- 创建索引的注意事项，使用原则
- 创建排查和消除慢查询

**什么是索引?**

- 索引是数据表中一个或多个列进行排序的数据结构
- 索引能够大幅度提升检索速度(回顾下查找结构：二叉搜索树，平衡数，多路平衡数)
- 创建，更新索引本身也会消耗空间和时间

**查找结构进化史**

- 线性查找：一个一个找，实现简单，速度慢
- 二分查找：简单，查找快，但要求是有序的，插入特别慢
- HASH：查询快，占用空间，不太适合存储大规模的数据
- 二叉查找树：插入和查询很快(log(n))，无法存大规模数据，复杂退化问题
- 平衡数：解决bst退化的问题，树是平衡的；节点非常多的时候，树依然很高
- 多路查找树：一个父亲多个孩子节点，书不会特别深
- 多路平衡查找树：B-Tree

> [数据结构可视化网站](https://：www.cs.usfca.edu/~galles/visualization/Algorithms.html)

**什么是B-Tree?**

- 多路平衡查找树(每个节点最多m(m>=2)个孩子，称为m阶或者度)
- 叶节点具有相同深度
- 节点中的数据key从做到右四递增的

**什么是B+Tree**

- Mysql实际使用的是B+Tree作为索引的数据结构
- 只在叶子节点带有指向的指针，可以增加书的度
- 叶子节点通过指针相连，实现范围查询

**Mysql索引类型**

- 普通索引
- 唯一索引
- 多列索引
- 主键索引
- 全文索引InnoDB不支持

**什么时候创建索引**

- 经常用作查询条件的字段(WHERE条件)
- 经常用锁表连接的字段
- 经常出现order by，ground by之后的字段

**创建索引右那些需要注意的**

- 非空字典NOT NULL，Mysql很难多空值查询优化
- 区分度高，离散度大，作为索引的字段值尽量不要右大量相同值
- 索引长度不要太长(比较耗费时间)

**索引什么时候失效**

- 模糊匹配：以%开头的LIKE语句，模糊搜索
- 类型隐转：出现隐式类型转换(在python这种动态语言中查询需要特别注意)
- 没有满足最左前缀原则

**什么式聚集索引和非聚集索引**

- 聚集还是非聚集指的式B+Tree叶节点的是指针还是数据记录
- MyISAM索引和数据分离，使用的是非聚集索引
- InnoDB数据文件就是索引文件，主键索引就是聚集索引

**如何排查慢查询**

- 慢查询通常是缺少索引，索引不合理或业务逻辑代码实现导致
- slow_query_log_file开启并且查询了慢查询日志
- 通过explain排查索引问题
- 调整数据修改索引；业务代码层限制不合理访问

------

### 6.2.3.Mysql语句常考题

**SQL语句已考察各种各种连接为重点**

- 内链接(INNER JOIN)：两个表存在匹配时，才会返回匹配行
  - 将左表和右表能关联起来的数据连接后返回
  - 类似于求两个表的“交集”
  - select * from A innner join B on a .id =v .id
- 外连接(LEFT/RIGHT JOIN)：返回一个表的行，即使另外一个没有匹配
  - 左连接返回坐标中所有记录，几时右表中没有匹配的记录
  - 左连接返回右表中所有记录，几时坐标中没有匹配的记录
  - 没有匹配的字段会设置成NULL
  - Mysql中使用left join和right jion实现
- 全链接(FULL  JOIN):只要某一个表存在匹配就返回
  - 只要某一个表存在匹配，就返回行
  - 类似求两个表的“并集”
  - 但是Mysql不支持，可以用left jion，union，right join联合使用模拟

### 6.2.4.Mysql思考题

- 为什么Mysql数据库的主键使用自增的增数比较好？
  &emsp;&emsp;对于这个问题需要从MySQL的索引以及存储引擎谈起：
  &emsp;&emsp;InnoDB的primary key为cluster index,除此之外，不能通过其他方式指定cluster index,如果InnoDB不指定primary key,InnoDB会找一个unique not null的field做cluster index,如果还没有这样的字段，则InnoDB会建一个非可见的系统默认的主键---row_id(6个字节长)作为cluster_index。
  &emsp;&emsp;建议使用数字型auto_increment的字段作为cluster index。不推荐用字符串字段做cluster index (primary key) ,因为字符串往往都较长， 会导致secondary index过大(secondary index的叶子节点存储了primary key的值),而且字符串往往是乱序。cluster index乱序插入容易造成插入和查询的效率低下。
- 使用uuid可以？为什么？
  - 自增ID节省一半磁盘空间
  - 单个数据走索引查询，自增id和uuid相差不大
  - 范围like查询，自增ID性能优于UUID
  - 写入测试，自增ID是UUID的4倍
  - 备份和恢复，自增ID性能优于UUID
- 如果是分布式系统下怎么生成数据库的自增?
  分布式架构，意味着需要多个实例中保持一个表的主键的唯一性。这个时候普通的单表自增ID主键就不太合适，因为多个mysql实例上会遇到主键全局唯一性问题。
  - 自增ID主键+步长，适合中等规模的分布式景
    &emsp;&emsp;在每个集群节点组的master上面，设置（auto_increment_increment），让目前每个集群的起始点错开 1，步长选择大于将来基本不可能达到的切分集群数，达到将 ID 相对分段的效果来满足全局唯一的效果。
    &emsp;&emsp;优点是：实现简单，后期维护简单，对应用透明。
     &emsp;&emsp;缺点是：第一次设置相对较为复杂，因为要针对未来业务的发展而计算好足够的步长;
  - UUID，适合小规模的分布式环境
    &emsp;&emsp;对于InnoDB这种聚集主键类型的引擎来说，数据会按照主键进行排序，由于UUID的无序性，InnoDB会产生巨大的IO压力，而且由于索引和数据存储在一起，字符串做主键会造成存储空间增大一倍。
    &emsp;&emsp;在存储和检索的时候，innodb会对主键进行物理排序，这对auto_increment_int是个好消息，因为后一次插入的主键位置总是在最后。但是对uuid来说，这却是个坏消息，因为uuid是杂乱无章的，每次插入的主键位置是不确定的，可能在开头，也可能在中间，在进行主键物理排序的时候，势必会造成大量的 IO操作影响效率，在数据量不停增长的时候，特别是数据量上了千万记录的时候，读写性能下降的非常厉害。
    优点：搭建比较简单，不需要为主键唯一性的处理。
    缺点：占用两倍的存储空间（在云上光存储一块就要多花2倍的钱），后期读写性能下降厉害。
  - 雪花算法自造全局自增ID，适合大数据环境的分布式场景。由twitter公布的开源的分布式id算法snowflake

