# 5.2.操作系统内存管理机制

## 5.2.操作系统内存管理机制

**什么是分页机制**
操作系统为了搞笑管理内存，减少碎片，逻辑地址和物理地址分离的内存分配管理方案

- 程序的逻辑地址划分为固定大小的页(Page)
- 物理地址划分为同样大小的帧(Frame)
- 通过页表对应逻辑地址和物理地址

> ![分页](https://jk-97.github.io/my_note/sources/index_分页机制.png)

**什么是分段机制**
分段式为了满足代码的一些逻辑需求

- 数据共享，数据保护，动态链接库等
- 通过段表实现逻辑地址和物理地址的映射关系
- 每个段类不式连续内存分配，段和段直接式离散分配的(每个段是出于实现相同的一个功能来进行分配)

> ![分段](https://jk-97.github.io/my_note/sources/index_分段机制.png)

**分页和分段的区别**

- 页是出于内存利用率的角度提出离散分配机制
- 段是出于用户角度，出于用户数据保护，数据隔离等用途的管理机制
- 页的大小是固定的，操作系统决定；段的大小不确定，用户程序决定

**什么是虚拟内存**
通过把一部分了暂时不用的的内存信息放到硬盘上

- 局部性原理，程序运行时候只有部分必要的信息转入内存
- 内存中暂时不需要的内容放到硬盘上
- 系统似乎提供了比实际内存大得很多的内存容量，称之为虚拟内存

**什么是内存抖动**

- 本质是频繁的页调度行为
- 频繁的页调度，进程不断产生缺页中断
- 置换一个页，又不断再次需要这个页
- 运行程序太多；分页替换策略不好。终止进程或者增加物理内存

**Python的垃圾回收机制原理**

- 引用计数为主(缺点：循环引用无法解决)
- 引用标记清楚和分代回收解决引用计数的问题
- 引用计数为主+标记清除和分代回收为辅

**引用计数**

```python
a = [1]     #ref 1
b = a       #ref 2
b=None      #ref 1  
del a       #ref 0  回收
```

**标记清除**

```python
a = [1]     #a ref 1 
b = [2]     #b ref 1
a.append(b) #b ref 2
b.append(a) #a ref 2
del a       #a ref 1
del b       #b ref 1    无法归零回收
```

> ![标记清楚](https://jk-97.github.io/my_note/sources/index_分代回收.png)
> 通过root节点搜索可以达到的节点，不可达到的点标为灰色，回收

***分代回收***

- 给对象记录下一个age，随着每一次垃圾回收，这个age会增加；
- 给不同age的对象分配不同的堆内内存空间，称为某一代；
- 对某一代的空间，有适合其的垃圾回收算法；
- 对每代进行不同垃圾回收，一般会需要一个额外的信息：即每代中对象被其他代中对象引用的信息。这个引用信息对于当前代来说，扮演与"root"一样的角色，也是本代垃圾回收的起点。